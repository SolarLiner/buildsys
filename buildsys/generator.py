import shlex
from pathlib import Path
from typing import Iterable, TextIO, List, Union

from . import __version__
from .compiler import BaseCompiler, relative_recursive
from .project import Project, ProjectType


class BaseGenerator:
    compiler: BaseCompiler

    def __init__(self, compiler: BaseCompiler):
        self.compiler = compiler

    @property
    def build_dir(self):
        return self.compiler.build_dir

    @property
    def source_dir(self):
        return self.compiler.source_dir

    def generate_project(self, project: Project):
        if not self.build_dir.exists():
            self.build_dir.mkdir(0o755, parents=True)
        elif self.build_dir.exists() and not self.build_dir.is_dir():
            raise IOError("Build directory exists but is not a directory")
        elif (
            self.build_dir.exists()
            and self.build_dir.exists()
            and len(list(self.build_dir.iterdir())) > 0
        ):
            raise IOError("Build directory exists and is not empty")


class RawCommandsGenerator(BaseGenerator):
    def generate_project(self, project: Project):
        super().generate_project(project)
        script_path = self.build_dir / "build.sh"
        output_file = self.build_dir / project.name.replace(" ", "_")
        if project.type == ProjectType.StaticLibrary:
            output_file = output_file.with_suffix(".a")
        elif project.type == ProjectType.SharedLibrary:
            output_file = output_file.with_suffix(".so")

        lines = [
            s.strip()
            for s in f"""#!/usr/bin/env bash
        # Generated by buildsys, version {__version__}
        # If using version control, please ignore this file as it is generated automatically.

        set -e
        _oldpwd=$PWD
        cd "$(dirname "$0")" 
        """.splitlines()
        ]
        objs = list()
        for src in project.sources:
            obj, cmd = self.generate_object(project, src)
            if not obj.parent.exists():
                obj.parent.mkdir(parents=True)
            objs.append(obj)
            lines.append(shlex.join([str(c) for c in cmd]))
        lines.append(
            shlex.join([str(s) for s in self.compiler.link(objs, output_file, [])])
        )
        lines.append('cd "$_oldpwd"')
        with script_path.open("w") as f:
            f.writelines([line + "\n" for line in lines])

    def generate_object(self, project: Project, source: Path):
        obj_dir_relative = source.parent.relative_to(self.source_dir)
        object_path = (
            (self.build_dir / obj_dir_relative / source.stem)
            .with_suffix(".o")
            .resolve()
        )
        return object_path, self.compiler.compile(source, object_path, [])


class MakefileGenerator(BaseGenerator):
    rules: List["MakefileGenerator.MakefileRule"]

    class MakefileRule:
        def __init__(self, name: str, *dependencies: str):
            self.code = list()
            self.name = name
            self.dependencies = dependencies

        def add_code(self, code: Iterable[str]):
            self.code.extend(list(code))

        def render(self, f: TextIO):
            f.write(f"{self.name}: {' '.join(str(s) for s in self.dependencies)}\n")
            for code in self.code:
                f.write(f"\t{code}\n")
            f.write("\n")

    def __init__(self, compiler: BaseCompiler):
        super().__init__(compiler)
        self.rules = list()

    def generate_project(self, project: Project):
        super().generate_project(project)
        for src in project.sources:
            out_dir = self.build_dir / (src.parent.relative_to(self.source_dir))
            if not out_dir.exists():
                out_dir.mkdir(parents=True)

        rule_all = self.create_rule("all", project.name)
        rule_project = self.create_rule(
            project.name,
            *[
                (s.relative_to(self.source_dir)).with_suffix(".o")
                for s in project.sources
            ],
        )
        rule_project.add_code(["gcc $^ -o $@"])
        rule_o = self.create_rule(
            "%.o", f"{relative_recursive(self.source_dir, self.build_dir)}/%.c"
        )
        rule_o.add_code(["gcc -c $^ -o $@"])

        self.create_rule(".PHONY", rule_all)
        self.render_project()

    def render_project(self):
        makefile = self.build_dir / "Makefile"
        with makefile.open("w") as f:
            for rule in self.rules:
                rule.render(f)

    def create_rule(self, name: str, *dependencies: Union[str, MakefileRule]):
        rule = MakefileGenerator.MakefileRule(
            name,
            *[
                d.name if isinstance(d, MakefileGenerator.MakefileRule) else d
                for d in dependencies
            ],
        )
        self.rules.append(rule)
        return rule
